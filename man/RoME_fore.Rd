% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RoME_fore.R
\name{RoME_fore}
\alias{RoME_fore}
\title{Robust optimal reconciliation for hierarchical time series forecasting}
\usage{
RoME_fore(
  base,
  hierarchy,
  loss.diff,
  design.W = "OLS",
  matrix.W = NULL,
  lambda.shrink = NULL,
  varsigma = 0,
  tau = 1e-16,
  threshold.convergence = 1e-04,
  limit.iteration = 1000
)
}
\arguments{
\item{base}{The value of base forecasts.}

\item{hierarchy}{The hierarchy structure of \code{hts}.}

\item{loss.diff}{Type of loss function.}

\item{design.W}{The alternative designs for the covariance matrix of base forecast errors.}

\item{matrix.W}{The covariance matrix of first-step-ahead base forecasts of error term.}

\item{lambda.shrink}{Shrink parameter for the shrink covariance design.}

\item{varsigma}{A positive perturbation, the default is \code{varsigma = 0}.}

\item{tau}{A positive constant, the default is \code{tau = 1e-16}.}

\item{threshold.convergence}{The convergence threshold, the default set is 1e-4.}

\item{limit.iteration}{The limit iteration times, the default set is 1000.}
}
\value{
A list object, which is basically a list consisting of:
\item{RoME}{the forecast result of RoME method}
\item{time}{the computation time of RoME}
\item{call}{a \code{list} object contains arguments for RoME algorithm}
}
\description{
The RoME model for HTS forecasting. Return the forecast result and computation time.
}
\examples{
data("Tourism")
data <- Tourism$data
size.n = ncol(data)
H1 <- Tourism$H1
diag1<-diag(1,size.n)
S <- as.matrix(rbind(H1,diag1))
data.all = as.matrix(data) \%*\% t(S)
size.T = nrow(data)
size.m = ncol(data)
order.train = 1:96
order.test = (1:12)+96
data.train = data.all[order.train, ]
data.test = data.all[order.test, ]
sol.base = BaseAuto(x = data.train, method.forecast = 'ETS', term = 12)
sol.Wt = CovarianceW(data.train, method.forecast = 'ETS', is.rolling = FALSE)
sol.LAD <- RoME_fore(base = sol.base$base, hierarchy = S, loss.diff = DiffLoss(type = 'LAD'),
design.W = 'OLS', matrix.W = sol.Wt$W, lambda.shrink = sol.Wt$lambda)

}
